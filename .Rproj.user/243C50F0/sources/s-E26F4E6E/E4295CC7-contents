### Preliminaries
library(R2jags); library(coda);library(rjags);library(psych);library(MASS)
top <- '/Users/kman/Documents/Cheating behaviour analysis/JAGS files'
d <- '/Users/kman/Documents/Cheating behaviour analysis/JAGS files' 
n.reps <- 1 ###
rho <- 0
condition <- paste('cor=',rho,sep='')
model.dir <- '/Users/kman/Documents/Cheating behaviour analysis/JAGS files/lognorm_model.txt' 
setwd('/Users/kman/Documents/Cheating behaviour analysis/JAGS files')
#wd <- file.path(d,condition,'Lognorm')
wd <- file.path(d)

## DATA read in
library(readxl)
Form <- as.data.frame(example_dataset_updated)
summary(Form)
str(Form)

# RT and Item responses extraction 
Resp.A <- Form[,111:210]
RT.A <- as.numeric(Form[,211:310])
RT.A[RT.A == 0] <- NA  
summary(RT.A)
summary(Resp.A)


##################################################### IRT model fitting  ##################################################
library(mirt)
fit.A <- mirt(Resp.A,1,itemtype='Rasch')
fit.A
fit.item.A <- coef(fit.A, IRTpars=T,as.data.frame=T)
theta.A <- fscores(fit.A)
theta.A
hist(theta.A)

##################################################### RT model fitting              ###################################################
## RT model estimation preparation 
n.reps <- 1 
rho <- 0
condition <- paste('cor=',rho,sep='')

#####################################################
### Input/Settings

### Prior for mean & covariance matrix of alpha & beta
mu <- c(1,3.5)
V <- diag(10,2,2)

### MCMC settings
n.samples <- 6000
n.burn <- 1000
thin.int <- 5
floor((n.samples - n.burn)/thin.int) # number of samples to keep

params <- c("alpha","beta","mu.ipar","var.ipar","speed","sd.speed") # to monitor

RT <- RT.A
N <- nrow(RT); m <- ncol(RT)

jags.data <- list(N=N, m=m, RT=RT, mu=mu, V=V)

#####################################################
### Initial values
### RT model
logRTs <- log(RT)
alpha_hat <- 1/apply(logRTs,2,sd)
beta_hat <- apply(logRTs,2,mean)
speed_hat <- mean(beta_hat) - apply(logRTs,1,mean)

### 2nd-order model
prec.speed <- 1
mu.ipar <- c(mean(alpha_hat),mean(beta_hat))
prec.ipar <- diag(1,2,2)

### Create the list of lists
jags.inits <- list()
jags.inits[[2]] <- list( speed=speed_hat, prec.speed=prec.speed,ipar=cbind(alpha_hat,beta_hat), mu.ipar=mu.ipar, prec.ipar=prec.ipar)

#####################################################
### Run JAGS
out <- jags(data=jags.data, inits=jags.inits, parameters.to.save=params, model.file=model.dir, n.chains=2, n.iter=n.samples, n.burnin=n.burn, n.thin=thin.int)

options(max.print=1000000)
capture.output(up.out.2$BUGSoutput, file ="Form.txt")
#####################################################
### Convert output to mcmc objects
s <- n.burn+thin.int

### Create mcmc objects
up.out.speed <- mcmc(out$BUGSoutput$sims.list$speed, start=s, thin=thin.int)
up.out.sd.speed <- mcmc(out$BUGSoutput$sims.list$sd.speed, start=s, thin=thin.int)

up.out.alpha <- mcmc(out$BUGSoutput$sims.list$alpha, start=s, thin=thin.int)
up.out.beta <- mcmc(out$BUGSoutput$sims.list$beta, start=s, thin=thin.int)
up.out.mu <- mcmc(out$BUGSoutput$sims.list$mu.ipar, start=s, thin=thin.int)
up.out.Var <- out$BUGSoutput$sims.list$var.ipar
temp <- cbind(up.out.Var[,1,1], up.out.Var[,2,2], up.out.Var[,1,2])
up.out.var <- mcmc(temp, start=s, thin=thin.int)

### Create summary objects
sum.speed <- summary(up.out.speed)
sum.sd.speed <- summary(up.out.sd.speed)

sum.alpha <- summary(up.out.alpha)
sum.beta <- summary(up.out.beta)
sum.mu <- summary(up.out.mu)
sum.var <- summary(up.out.var)

#####################################################
### Compute/save parameter estimates
### Person parameters
ppars<- as.data.frame(sum.speed$statistics[,1:2])
names(ppars) <- c('tau.hat','tau.sd')

### Item parameters
ipars <- as.data.frame(cbind(sum.alpha$statistics[,1:2], sum.beta$statistics[,1:2]))
names(ipars) <- c('alpha.hat','sd.alpha','beta.hat','sd.beta')


#####################################################
#####################################################
### MCMC convergence stuff 

### ACF plots
autocorr.plot(up.out.sd.speed)
autocorr.plot(up.out.mu,ask=T)
autocorr.plot(up.out.var,ask=T)

autocorr.plot(up.out.alpha,ask=T)
autocorr.plot(up.out.beta,ask=T)

### Trace plots
plot(up.out.sd.speed)
plot(up.out.mu)
plot(up.out.var)

plot(up.out.alpha)
plot(up.out.beta)

### Geweke's convergence diagnostic
round(geweke.diag(up.out.sd.speed, frac1=.1, frac2=.5)$z, digits=2)
round(geweke.diag(up.out.mu, frac1=.1, frac2=.5)$z, digits=2)
round(geweke.diag(up.out.var, frac1=.1, frac2=.5)$z, digits=2)

gew <- cbind(
  geweke.diag(up.out.alpha, frac1=.1, frac2=.5)$z,
  geweke.diag(up.out.beta, frac1=.1, frac2=.5)$z)
round(ifelse(abs(gew) > 1.9,gew,NA),digits=2)

##################################################### PFS calculation               ####
##################### IRT based PFS calculation      ##########################
###### HT index
library(PerFit)
Ht.psf.A <- Ht(Resp.A)
plot(Ht.psf.A)
Ht.cut.A <- cutoff(Ht.psf.A,Blvl=.05,Nrep=1000)
plot(Ht.psf.A, cutoff.obj=Ht.cut.A,Type="Both",Blv1=0.05,CIlv1=0.9,Xcex=0.8,col.hist="grey",col.area="NA",col.ticks="NA", title="",Xlabel="")

###### Lzstar  index
Lzstar.psf.A <- lzstar(Resp.A,IRT.PModel = "1PL")
Lzstar.cut.A <- cutoff(Lzstar.psf.A,Blvl=.05,Nrep=1000)
plot(Lzstar.psf.A, cutoff.obj=Lzstar.cut.A,Type="Both",Blv1=0.05,CIlv1=0.9,Xcex=0.8,col.hist="grey",col.area="NA",col.ticks="NA",title="")
Lzstar.cut.A

###### NCI index
NCI.psf.A <- NCI(Resp.A)
NCI.cut.A <- cutoff(NCI.psf.A ,Blvl=.05,Nrep=1000)
plot(NCI.psf.A, Type="Both",Blv1=0.05,CIlv1=0.9,Xcex=0.8,col.hist="grey",col.area="NA",col.ticks="NA",title="")


##################### RT based PFS calculation       ##########################
#### Lt index Marianti & Fox
rt.alpha.A <- as.vector(ipars$alpha.hat)
rt.beta.A <- as.vector(ipars$beta.hat)
rt.tau.A <- as.matrix(ppars$tau.hat)
Form.A.RT <- as.matrix(RT.A)
I <- ncol(Form.A.RT)
J <- nrow(Form.A.RT)
Z.A=matrix(0,nrow=J,ncol=I)
for(i in 1:I){
  for(j in 1:J){
    Z.A[j,i]<- ((log(Form.A.RT[j,i])-(rt.beta.A[i]-rt.tau.A[j]))*rt.alpha.A[i])^2
  }
}
Z_sum.A <- apply(Z.A,1,sum)
plot(Z_sum.A,col="grey")
hist(Z_sum.A,,col="grey",main = "",xlab="Lz",breaks=20)
abline(v=qchisq(0.95,170))


# KL index programming 
Cheating=Form.A.RT
average_cheating <- (apply(Cheating,2,sum)/J)
average_cheating
w2 <- sum(average_cheating)
w2
w_average_cheat <- average_cheating*(1/w2)
w_average_cheat
w1 <- apply(Cheating,1,sum)

KLdata <- diag(1/w1) %*% Cheating

summary(KLdata)
start.time <- Sys.time()
KLD=rep(0,J)
for (i in 1:J){
  KLD[i]= sum(w_average_cheat %*% log(w_average_cheat/KLdata[i,]));
}
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
hist(KLD)
Critical <-quantile(KLD,probs=c(0.5))+1.5*(quantile(KLD,probs=c(0.75))-quantile(KLD,probs=c(0.5)))
Critical
abline(v=Critical)
