speed[i] ~ dnorm(0, prec.speed)
}
prec.speed ~ dgamma(.001,.001)
sd.speed <- sqrt(1/prec.speed)
for (j in 1:m) {
alpha[j] <- ipar[j,1]
beta[j] <- ipar[j,2]
ipar[j,1:2] ~ dmnorm(mu.ipar[1:2], prec.ipar[1:2,1:2])
}
mu <- c(1,3.5)
V[1,1] <- 5
V[2,1] <- 0
V[1,2] <- 0
V[2,2] <- 5
mu.ipar[1:2] ~ dmnorm(mu[1:2], prec.ipar[1:2,1:2])
prec.ipar[1:2,1:2] ~ dwish(V[1:2,1:2], 2)
var.ipar[1:2,1:2] <- inverse(prec.ipar[1:2,1:2])
}
Data{
list(RT = structure(.Data = VRT.matrix,
.Dim = c(1636, 20)),N = nrow(RT), m = ncol(RT))
}
"
results <- run.jags(model, monitor=c("alpha","beta","mu.ipar","var.ipar","speed","sd.speed"))
### Convert output to mcmc objects
n.burn <- 1000
thin.int <- 5
s <- n.burn+thin.int
model.dir <- '~/Desktop//lognorm_model.txt'
##################################################### RT model fitting              ###################################################
## RT model estimation preparation
n.reps <- 1
rho <- 0
condition <- paste('cor=',rho,sep='')
### Prior for mean & covariance matrix of alpha & beta
mu <- c(1,3.5)
V <- diag(10,2,2)
### MCMC settings
n.samples <- 6000
n.burn <- 1000
thin.int <- 5
params <- c("alpha","beta","mu.ipar","var.ipar","speed","sd.speed") # to monitor
RT <- RT.A
N <- nrow(RT); m <- ncol(RT)
jags.data <- list(N=N, m=m, RT=RT, mu=mu, V=V)
#####################################################
### Initial values
### RT model
logRTs <- log(RT)
alpha_hat <- 1/apply(logRTs,2,sd)
beta_hat <- apply(logRTs,2,mean)
speed_hat <- mean(beta_hat) - apply(logRTs,1,mean)
### 2nd-order model
prec.speed <- 1
mu.ipar <- c(mean(alpha_hat),mean(beta_hat))
prec.ipar <- diag(1,2,2)
### Create the list of lists
jags.inits <- list()
jags.inits[[2]] <- list( speed=speed_hat, prec.speed=prec.speed,ipar=cbind(alpha_hat,beta_hat), mu.ipar=mu.ipar, prec.ipar=prec.ipar)
#####################################################
### Run JAGS
out <- jags(data=jags.data, inits=jags.inits, parameters.to.save=params, model.file=model.dir, n.chains=2, n.iter=n.samples, n.burnin=n.burn, n.thin=thin.int)
### Preliminaries
library(R2jags); library(coda);library(rjags);library(psych);library(MASS)
#####################################################
### Run JAGS
out <- jags(data=jags.data, inits=jags.inits, parameters.to.save=params, model.file=model.dir, n.chains=2, n.iter=n.samples, n.burnin=n.burn, n.thin=thin.int)
View(RT)
RT = as.data.frame(RT)
#####################################################
### Run JAGS
out <- jags(data=jags.data, inits=jags.inits, parameters.to.save=params, model.file=model.dir, n.chains=2, n.iter=n.samples, n.burnin=n.burn, n.thin=thin.int)
RT = as.data.frame(example_dataset[,c(50:69)])
RT[RT == 0] <- NA
#####################################################
### Initial values
### RT model
logRTs <- log(RT)
alpha_hat <- 1/apply(logRTs,2,sd)
beta_hat <- apply(logRTs,2,mean)
speed_hat <- mean(beta_hat) - apply(logRTs,1,mean)
### 2nd-order model
prec.speed <- 1
mu.ipar <- c(mean(alpha_hat),mean(beta_hat))
prec.ipar <- diag(1,2,2)
### Create the list of lists
jags.inits <- list()
jags.inits[[2]] <- list( speed=speed_hat, prec.speed=prec.speed,ipar=cbind(alpha_hat,beta_hat), mu.ipar=mu.ipar, prec.ipar=prec.ipar)
#####################################################
### Run JAGS
out <- jags(data=jags.data, inits=jags.inits, parameters.to.save=params, model.file=model.dir, n.chains=2, n.iter=n.samples, n.burnin=n.burn, n.thin=thin.int)
#####################################################
### Run JAGS
out <- jags(data=jags.data, inits=jags.inits, parameters.to.save=params, model.file=model.dir, n.chains=2, n.iter=n.samples, n.burnin=n.burn, n.thin=thin.int)
?autocorr.plot
#####################################################
### Initial values
### RT model
logRTs <- log(RT)
alpha_hat <- 1/apply(logRTs,2,sd)
beta_hat <- apply(logRTs,2,mean)
speed_hat <- mean(beta_hat) - apply(logRTs,1,mean)
### 2nd-order model
prec.speed <- 1
mu.ipar <- c(mean(alpha_hat),mean(beta_hat))
prec.ipar <- diag(1,2,2)
### Create the list of lists
jags.inits <- list()
jags.inits[[2]] <- list( speed=speed_hat, prec.speed=prec.speed,ipar=cbind(alpha_hat,beta_hat), mu.ipar=mu.ipar, prec.ipar=prec.ipar)
#####################################################
### Run JAGS
out <- jags(data=jags.data, inits=jags.inits, parameters.to.save=params, model.file=model.dir, n.chains=2, n.iter=n.samples, n.burnin=n.burn, n.thin=thin.int)
#options(max.print=1000000)
#capture.output(up.out.2$BUGSoutput, file ="Form.txt")
#####################################################
### Convert output to mcmc objects
s <- n.burn+thin.int
Resp = as.data.frame(example_dataset[,c(30:49)])
View(Resp)
##################################################### PFS calculation               ####
##################### IRT based PFS calculation      ##########################
###### HT index
library(PerFit)
a=c(1:10)
hist(a)
abline()
abline(1,a)
list(hist(a),abline(1,2))
return(hist(a),abline(1,2))
c(hist(a),abline(2,1))
library(mtcars)
?par
par(mfrow=c(2,2))
secmin = function(RT,Resp) {
RT.matrix = matrix(c(unlist(RT)),nrow=nrow(RT),ncol = ncol(RT))
model <- "
Poisson model...
model {
for (i in 1:N) {
for (j in 1:m) {
RT[i,j] ~ dlnorm(beta[j] - speed[i], alpha[j]^2)
}
speed[i] ~ dnorm(0, prec.speed)
}
prec.speed ~ dgamma(.001,.001)
sd.speed <- sqrt(1/prec.speed)
for (j in 1:m) {
alpha[j] <- ipar[j,1]
beta[j] <- ipar[j,2]
ipar[j,1:2] ~ dmnorm(mu.ipar[1:2], prec.ipar[1:2,1:2])
}
mu <- c(1,3.5)
V[1,1] <- 5
V[2,1] <- 0
V[1,2] <- 0
V[2,2] <- 5
mu.ipar[1:2] ~ dmnorm(mu[1:2], prec.ipar[1:2,1:2])
prec.ipar[1:2,1:2] ~ dwish(V[1:2,1:2], 2)
var.ipar[1:2,1:2] <- inverse(prec.ipar[1:2,1:2])
}
Data{
list(RT = structure(.Data = RT.matrix,
.Dim = c(nrow(RT), ncol(RT))),N = nrow(RT), m = ncol(RT))
}
"
out <- run.jags(model, monitor=c("alpha","beta","mu.ipar","var.ipar","speed","sd.speed"))
### Convert output to mcmc objects
n.burn <- 1000
thin.int <- 5
s <- n.burn+thin.int
### Create mcmc objects
up.out.speed <- mcmc(out$BUGSoutput$sims.list$speed, start=s, thin=thin.int)
up.out.sd.speed <- mcmc(out$BUGSoutput$sims.list$sd.speed, start=s, thin=thin.int)
up.out.alpha <- mcmc(out$BUGSoutput$sims.list$alpha, start=s, thin=thin.int)
up.out.beta <- mcmc(out$BUGSoutput$sims.list$beta, start=s, thin=thin.int)
up.out.mu <- mcmc(out$BUGSoutput$sims.list$mu.ipar, start=s, thin=thin.int)
up.out.Var <- out$BUGSoutput$sims.list$var.ipar
temp <- cbind(up.out.Var[,1,1], up.out.Var[,2,2], up.out.Var[,1,2])
up.out.var <- mcmc(temp, start=s, thin=thin.int)
### Create summary objects
sum.speed <- summary(up.out.speed)
sum.sd.speed <- summary(up.out.sd.speed)
sum.alpha <- summary(up.out.alpha)
sum.beta <- summary(up.out.beta)
sum.mu <- summary(up.out.mu)
sum.var <- summary(up.out.var)
#####################################################
### Compute/save parameter estimates
### Person parameters
ppars<- as.data.frame(round(sum.speed$statistics[,1:2],3)) # function output
names(ppars) <- c('tau.hat','tau.sd')
### Item parameters
ipars <- as.data.frame(round(cbind(sum.alpha$statistics[,1:2], sum.beta$statistics[,1:2]),3)) # function output
names(ipars) <- c('alpha.hat','sd.alpha','beta.hat','sd.beta')
#####################################################
#####################################################
### MCMC convergence stuff
### ACF plots
sd.speed.ACFplot <- autocorr.plot(up.out.sd.speed)
mu.ACFplot <- autocorr.plot(up.out.mu,ask=T)
var.ACFplot <- autocorr.plot(up.out.var,ask=T)
alpha.ACFplot <- autocorr.plot(up.out.alpha,ask=T)
beta.ACFplot <- autocorr.plot(up.out.beta,ask=T)
### Trace plots
sd.speed.traceplot<- plot(up.out.sd.speed)
mu.traceplot<- plot(up.out.mu)
var.traceplot <- plot(up.out.var)
alpha.traceplot <- plot(up.out.alpha)
beta.traceplot <- plot(up.out.beta)
### Geweke's convergence diagnostic --- function output
round(geweke.diag(up.out.sd.speed, frac1=.1, frac2=.5)$z, digits=2)
round(geweke.diag(up.out.mu, frac1=.1, frac2=.5)$z, digits=2)
round(geweke.diag(up.out.var, frac1=.1, frac2=.5)$z, digits=2)
gew <- cbind(
geweke.diag(up.out.alpha, frac1=.1, frac2=.5)$z,
geweke.diag(up.out.beta, frac1=.1, frac2=.5)$z)
round(ifelse(abs(gew) > 1.9,gew,NA),digits=2)
##################################################### PFS calculation               ####
##################### IRT based PFS calculation      ##########################
###### HT index
library(PerFit)
Ht.psf.A <- PerFit::Ht(Resp)
#plot(Ht.psf.A)
Ht.cut.A <- PerFit::cutoff(Ht.psf.A,Blvl=.05,Nrep=1000)
HT.plot <- plot(Ht.psf.A, cutoff.obj=Ht.cut.A,Type="Both",Blv1=0.05,CIlv1=0.9,Xcex=0.8,col.hist="grey",col.area="NA",col.ticks="NA", title="",Xlabel="")
###### Lzstar  index
Lzstar.psf.A <- lzstar(Resp.A,IRT.PModel = "1PL")
Lzstar.cut.A <- cutoff(Lzstar.psf.A,Blvl=.05,Nrep=1000)
Lzstar.plot <- plot(Lzstar.psf.A, cutoff.obj=Lzstar.cut.A,Type="Both",Blv1=0.05,CIlv1=0.9,Xcex=0.8,col.hist="grey",col.area="NA",col.ticks="NA",title="")
###### NCI index
NCI.psf.A <- NCI(Resp.A)
NCI.cut.A <- cutoff(NCI.psf.A ,Blvl=.05,Nrep=1000)
NCI.plot <- plot(NCI.psf.A, Type="Both",Blv1=0.05,CIlv1=0.9,Xcex=0.8,col.hist="grey",col.area="NA",col.ticks="NA",title="")
##################### RT based PFS calculation       ##########################
#### Lt index Marianti & Fox
rt.alpha.A <- as.vector(ipars$alpha.hat)
rt.beta.A <- as.vector(ipars$beta.hat)
rt.tau.A <- as.matrix(ppars$tau.hat)
Form.A.RT <- as.matrix(RT)
I <- ncol(Form.A.RT)
J <- nrow(Form.A.RT)
Z.A=matrix(0,nrow=J,ncol=I)
for(i in 1:I){
for(j in 1:J){
Z.A[j,i]<- ((log(Form.A.RT[j,i])-(rt.beta.A[i]-rt.tau.A[j]))*rt.alpha.A[i])^2
}
}
Z_sum.A <- apply(Z.A,1,sum)
plot(Z_sum.A,col="grey")  #add plot
hist(Z_sum.A,,col="grey",main = "",xlab="Lz",breaks=20) ## add plot
abline(v=qchisq(0.95,170))
# KL index programming
Cheating=Form.A.RT
Cheating[is.na(Cheating)] <- 0
average_cheating <- (apply(Cheating,2,sum)/J)
average_cheating
w2 <- sum(average_cheating)
w2
w_average_cheat <- average_cheating*(1/w2)
w_average_cheat
w1 <- apply(Cheating,1,sum)
KLdata <- diag(1/w1) %*% Cheating
summary(KLdata)
start.time <- Sys.time()
KLD=rep(0,J)
for (i in 1:J){
KLD[i]= sum(w_average_cheat %*% log(w_average_cheat/KLdata[i,]));
}
end.time <- Sys.time()
time.taken <- end.time - start.time
time.taken
Critical <-quantile(KLD,probs=c(0.5))+1.5*(quantile(KLD,probs=c(0.75))-quantile(KLD,probs=c(0.5)))
Critical
KLD.plot = c(hist(KLD),abline(v=Critical)) # function output
cheating.cases <- which(KLD>Critical) # function output
ACFplots = c(sd.speed.ACFplot,
mu.ACFplot,
var.ACFplot,
alpha.ACFplot,
beta.ACFplot)
traceplots = c(sd.speed.traceplot,
mu.traceplot,
var.traceplot,
alpha.traceplot,
beta.traceplot)
par(mfrow=c(2,3))
return(list(model = out, ppars, ipars, cheating.cases, ACFplots, traceplots,
HTplot,
Lzstar.plot,
NCI.plot,
KLD.plot))
}
?mfrow
??mfrow
?mcmc
?geweke.diag
?lzstar
?NCI
library(devtools)
check()
rm()
check()
library(devtools)
check()
check()
check
check()
?abline
?qchisq
?quantile
?HTplot
check()
check()
load_all()
load("~/Library/CloudStorage/Box-Box/GitHub/SecMin/data/example_dataset.rda")
RT = as.data.frame(example_dataset[c(1:10),c(50:69)])
Resp = as.data.frame(example_dataset[c(1:10),c(30:49)])
View(Resp)
View(RT)
secmin(RT,Resp)
return(RT.matrix)}
x= function(RT) {
RT.matrix = matrix(c(unlist(RT)),nrow=nrow(RT),ncol = ncol(RT)),
return(RT.matrix)}
x= function(RT) {RT.matrix = matrix(c(unlist(RT)),nrow=nrow(RT),ncol = ncol(RT))
return(RT.matrix)
}
x(RT)
x = x(RT)
View(x)
secmin(RT,Resp)
check()
RT = as.data.frame(example_dataset[c(1:10),c(50:69)])
Resp = as.data.frame(example_dataset[c(1:10),c(30:49)])
secmin(RT,Resp)
x = function(RT,Resp) {
RT = matrix(c(unlist(RT)),nrow=nrow(RT),ncol = ncol(RT))
model <- "
Poisson model...
model {
for (i in 1:N) {
for (j in 1:m) {
RT[i,j] ~ dlnorm(beta[j] - speed[i], alpha[j]^2)
}
speed[i] ~ dnorm(0, prec.speed)
}
prec.speed ~ dgamma(.001,.001)
sd.speed <- sqrt(1/prec.speed)
for (j in 1:m) {
alpha[j] <- ipar[j,1]
beta[j] <- ipar[j,2]
ipar[j,1:2] ~ dmnorm(mu.ipar[1:2], prec.ipar[1:2,1:2])
}
mu <- c(1,3.5)
V[1,1] <- 5
V[2,1] <- 0
V[1,2] <- 0
V[2,2] <- 5
mu.ipar[1:2] ~ dmnorm(mu[1:2], prec.ipar[1:2,1:2])
prec.ipar[1:2,1:2] ~ dwish(V[1:2,1:2], 2)
var.ipar[1:2,1:2] <- inverse(prec.ipar[1:2,1:2])
}
Data{
list(RT = structure(.Data = RT,
.Dim = c(nrow(RT), ncol(RT))),N = nrow(RT), m = ncol(RT))
}
"
out <- run.jags(model, monitor=c("alpha","beta","mu.ipar","var.ipar","speed","sd.speed"))
}
x = function(RT) {
RT = matrix(c(unlist(RT)),nrow=nrow(RT),ncol = ncol(RT))
model <- "
Poisson model...
model {
for (i in 1:N) {
for (j in 1:m) {
RT[i,j] ~ dlnorm(beta[j] - speed[i], alpha[j]^2)
}
speed[i] ~ dnorm(0, prec.speed)
}
prec.speed ~ dgamma(.001,.001)
sd.speed <- sqrt(1/prec.speed)
for (j in 1:m) {
alpha[j] <- ipar[j,1]
beta[j] <- ipar[j,2]
ipar[j,1:2] ~ dmnorm(mu.ipar[1:2], prec.ipar[1:2,1:2])
}
mu <- c(1,3.5)
V[1,1] <- 5
V[2,1] <- 0
V[1,2] <- 0
V[2,2] <- 5
mu.ipar[1:2] ~ dmnorm(mu[1:2], prec.ipar[1:2,1:2])
prec.ipar[1:2,1:2] ~ dwish(V[1:2,1:2], 2)
var.ipar[1:2,1:2] <- inverse(prec.ipar[1:2,1:2])
}
Data{
list(RT = structure(.Data = RT,
.Dim = c(nrow(RT), ncol(RT))),N = nrow(RT), m = ncol(RT))
}
"
out <- run.jags(model, monitor=c("alpha","beta","mu.ipar","var.ipar","speed","sd.speed"))
}
x = function(RT) {
RT = matrix(c(unlist(RT)),nrow=nrow(RT),ncol = ncol(RT))
model <- "
Poisson model...
model {
for (i in 1:N) {
for (j in 1:m) {
RT[i,j] ~ dlnorm(beta[j] - speed[i], alpha[j]^2)
}
speed[i] ~ dnorm(0, prec.speed)
}
prec.speed ~ dgamma(.001,.001)
sd.speed <- sqrt(1/prec.speed)
for (j in 1:m) {
alpha[j] <- ipar[j,1]
beta[j] <- ipar[j,2]
ipar[j,1:2] ~ dmnorm(mu.ipar[1:2], prec.ipar[1:2,1:2])
}
mu <- c(1,3.5)
V[1,1] <- 5
V[2,1] <- 0
V[1,2] <- 0
V[2,2] <- 5
mu.ipar[1:2] ~ dmnorm(mu[1:2], prec.ipar[1:2,1:2])
prec.ipar[1:2,1:2] ~ dwish(V[1:2,1:2], 2)
var.ipar[1:2,1:2] <- inverse(prec.ipar[1:2,1:2])
}
Data{
list(RT = structure(.Data = RT,
.Dim = c(nrow(RT), ncol(RT))),N = nrow(RT), m = ncol(RT))
}
"
out <- run.jags(model, monitor=c("alpha","beta","mu.ipar","var.ipar","speed","sd.speed"))
}
x(RT)
RT = matrix(c(unlist(RT)),nrow=nrow(RT),ncol = ncol(RT))
x = function(RT) {
model <- "
Poisson model...
model {
for (i in 1:N) {
for (j in 1:m) {
RT[i,j] ~ dlnorm(beta[j] - speed[i], alpha[j]^2)
}
speed[i] ~ dnorm(0, prec.speed)
}
prec.speed ~ dgamma(.001,.001)
sd.speed <- sqrt(1/prec.speed)
for (j in 1:m) {
alpha[j] <- ipar[j,1]
beta[j] <- ipar[j,2]
ipar[j,1:2] ~ dmnorm(mu.ipar[1:2], prec.ipar[1:2,1:2])
}
mu <- c(1,3.5)
V[1,1] <- 5
V[2,1] <- 0
V[1,2] <- 0
V[2,2] <- 5
mu.ipar[1:2] ~ dmnorm(mu[1:2], prec.ipar[1:2,1:2])
prec.ipar[1:2,1:2] ~ dwish(V[1:2,1:2], 2)
var.ipar[1:2,1:2] <- inverse(prec.ipar[1:2,1:2])
}
Data{
list(RT = structure(.Data = RT,
.Dim = c(nrow(RT), ncol(RT))),N = nrow(RT), m = ncol(RT))
}
"
out <- run.jags(model, monitor=c("alpha","beta","mu.ipar","var.ipar","speed","sd.speed"))
}
x(RT)
setwd("~/Library/CloudStorage/Box-Box/Academics/GA/ETS 2021/ETS data/Dr. He/Qingzhou")
load("~/Library/CloudStorage/Box-Box/Academics/GA/ETS 2021/ETS data/Dr. He/Qingzhou/HC5k2v3v.RData")
HC2varLv1.cm
View(HC2varLv1.cm)
HC2varLv1.cm[[2]]
HC2varLv1.cm[[2]]
High.cm[[2]]
Low.cm[[2]]
table(Hpro4)
table(LowHpro4)
lowH.tb =  as.data.frame(table(LowHpro4))
lowL.tb = as.data.frame(table(LowLpro4))
View(lowH.tb)
View(lowL.tb)
highH.tb =  as.data.frame(table(Hpro4))
highL.tb = as.data.frame(table(Lpro4))
View(lowH.tb)
View(highH.tb)
View(highL.tb)
View(lowH.tb)
highlow = matrix(lowH.tb,lowL.tb$Freq,highH.tb$Freq,highL.tb$Freq)
View(highlow)
highlow = cbind(lowH.tb,lowL.tb$Freq,highH.tb$Freq,highL.tb$Freq)
View(highlow)
highlow = t(highlow)
View(highlow)
rownames(highlow) = c('pred','pred.lv1','pred.blv1','pred.lv3','pred.lv2')
highlow = t(cbind(lowL.tb$Freq,lowH.tb$Freq,highL.tb$Freq,highH.tb$Freq))
View(highlow)
rownames(highlow) = c('pred.blv1','pred.lv1','pred.lv2','pred.lv3')
View(highlow)
colnames(highlow) = c('obs.blv1','obs.lv1','obs.lv2','obs.lv3')
View(highlow)
Low.pred
category <- c(1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0)
prediction <- rev(seq_along(category))
prediction[9:10] <- mean(prediction[9:10])
prediction
LowHpro4
